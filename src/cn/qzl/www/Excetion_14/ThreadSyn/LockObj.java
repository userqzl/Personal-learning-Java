package cn.qzl.www.Excetion_14.ThreadSyn;import java.util.Random;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author qzl * @Description * 使用对象锁进行同步，保证只有一个线程进入临界区，其他线程调用lock()时将会被阻塞 * @Since 2020-05-05 11:05 */public class LockObj implements Runnable{    private int ticket = 1000;    private Lock lock = new ReentrantLock();    @Override    public void run(){        Random random = new Random();        while(ticket>0){            lock.lock();           // if(ticket>0){                try {                    System.out.println(Thread.currentThread().getName()+"正在出售"+ticket--);                }                finally {                    lock.unlock();                    try {                        Thread.sleep(random.nextInt(5));                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            //}        }    }    public static void main(String[] args)    {        LockObj t = new LockObj();        Thread t1 = new Thread(t);        Thread t2 = new Thread(t);        Thread t3 = new Thread(t);        t1.setName("窗口1");        t2.setName("窗口2");        t3.setName("窗口3");        t1.start();        t2.start();        t3.start();    }}