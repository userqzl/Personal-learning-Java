package cn.qzl.www.Excetion_14.ThreadSyn;import java.util.Random;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @Author qzl * @Description * 条件对象，当获取锁却不满足条件时，放弃锁并进入等待集，等待其他线程调用signalAll()方法解除等待 * @Since 2020-05-06 10:28 */public class ConditionTest implements Runnable{    private int []account = {1000,2000,3000,1200,800};    private Lock lock = new ReentrantLock();    private Condition enoughMoney = lock.newCondition();//新建条件对象    Random random = new Random();    @Override    public void run(){        while(true){            transfer();        }    }    //转账    public void transfer(){        lock.lock();        int r = random.nextInt(100);   //转出金额        int acc_1 = random.nextInt(5);  //自己账户        int acc_2 = random.nextInt(5);  //他人账户        if(account[acc_1] > 1000) r+=500;        //转账方和收款方都是自己，重新随机收款方        while(acc_1 == acc_2) acc_2 = random.nextInt(5);        for(int i = 0;i < 5;++i){            //如果某个账户余额不足100，下次转账给它            if(account[i] < 100) acc_2 = i;        }        try{            //余额不足            while(account[acc_1]<r) {                try {                    enoughMoney.await();    //进入等待集阻塞                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            //开始转账            account[acc_1] -= r;            account[acc_2] += r;            enoughMoney.signalAll();   //解除等待集中的阻塞            System.out.println("---------------------------------------------");            System.out.println(Thread.currentThread().getName()+"-->账户["+acc_1+"]向账户["+acc_2+"]转账"+r+"元");            int i = 0;            for(int a:account){                System.out.println(Thread.currentThread().getName()+"-->账户["+ i++ +"]余额"+a);            }            System.out.println("---------------------------------------------");        }        finally {            lock.unlock();            try {                Thread.sleep(random.nextInt(1000));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args) {        ConditionTest c = new ConditionTest();        Thread t1 = new Thread(c);        Thread t2 = new Thread(c);        Thread t3 = new Thread(c);        t1.start();        t2.start();        t3.start();    }}